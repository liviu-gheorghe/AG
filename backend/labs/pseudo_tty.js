var pty = require('node-pty');
var WebSocket = require('ws');
var child_process = require('child_process');

const websocketServer = new WebSocket.Server({ port: 443 });
websocketServer.on('connection', function connection(proxyToServerSocket,request) {

    if (request.headers['sec-websocket-protocol'] != "TASK_MANAGEMENT_PROTOCOL")
        proxyToServerSocket.on('message', function incoming(message) {
        // if the connection was established without 
        // the task management protocol then it means 
        // that the received message should be written to 
        //the ptyProcess 
        ptyProcess.write(message);
    });
    else if (request.headers['sec-websocket-protocol'] == "TASK_MANAGEMENT_PROTOCOL")
    {
        proxyToServerSocket.on('message', function incoming(message) {
            // if the connection was established with 
            // the TASK_MANAGEMENT_POTOCOL then it means
            // that certain action should be perfomed in 
            // the container
            // The actions will be performed by spawning a 
            //child process
            console.log("Received command : ");
            child_process.exec(message,shell='/bin/bash');
        });
    }
    // Furthermore, if the socket is meant to write to the ptyProcess,
    // then send the data generated by the ptyProcess back to the websocket
    if (request.headers['sec-websocket-protocol'] != "TASK_MANAGEMENT_PROTOCOL")
    ptyProcess.on('data', (data) => {
        proxyToServerSocket.send(data);
    })
});
// Default shell, this pty will be used in an Ubuntu container
//so bash can be used by default
var shell = 'bash';
var ptyProcess = pty.spawn(shell, [], {
    name: 'xterm-color',
    cols: 120,
    rows: 30,
    cwd: process.env.HOME,
    env: process.env
});